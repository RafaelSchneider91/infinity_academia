import { Version } from '@angular/core';
import { getApps } from 'firebase/app';
export const VERSION = new Version('ANGULARFIRE2_VERSION');
export const ɵisSupportedError = (module) => `The APP_INITIALIZER that is "making" isSupported() sync for the sake of convenient DI has not resolved in this
context. Rather than injecting ${module} in the constructor, first ensure that ${module} is supported by calling
\`await isSupported()\`, then retrieve the instance from the injector manually \`injector.get(${module})\`.`;
export function ɵgetDefaultInstanceOf(identifier, provided, defaultApp) {
    if (provided) {
        // Was provide* only called once? If so grab that
        if (provided.length === 1) {
            return provided[0];
        }
        const providedUsingDefaultApp = provided.filter((it) => it.app === defaultApp);
        // Was provide* only called once, using the default app? If so use that
        if (providedUsingDefaultApp.length === 1) {
            return providedUsingDefaultApp[0];
        }
    }
    // Grab the default instance from the defaultApp
    const defaultAppWithContainer = defaultApp;
    const provider = defaultAppWithContainer.container.getProvider(identifier);
    return provider.getImmediate({ optional: true });
}
export const ɵgetAllInstancesOf = (identifier, app) => {
    const apps = app ? [app] : getApps();
    const instances = [];
    apps.forEach((app) => {
        const provider = app.container.getProvider(identifier);
        provider.instances.forEach((instance) => {
            if (!instances.includes(instance)) {
                instances.push(instance);
            }
        });
    });
    return instances;
};
export class ɵAppCheckInstances {
    constructor() {
        return ɵgetAllInstancesOf(ɵAPP_CHECK_PROVIDER_NAME);
    }
}
export const ɵAPP_CHECK_PROVIDER_NAME = 'app-check';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29yZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFeEMsT0FBTyxFQUFlLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUdwRCxNQUFNLENBQUMsTUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUUzRCxNQUFNLENBQUMsTUFBTSxpQkFBaUIsR0FBRyxDQUFDLE1BQWMsRUFBRSxFQUFFLENBQ2xEO2lDQUMrQixNQUFNLDBDQUEwQyxNQUFNO2dHQUNTLE1BQU0sTUFBTSxDQUFDO0FBTzdHLE1BQU0sVUFBVSxxQkFBcUIsQ0FBYSxVQUFrQixFQUFFLFFBQXVCLEVBQUUsVUFBdUI7SUFDcEgsSUFBSSxRQUFRLEVBQUUsQ0FBQztRQUNiLGlEQUFpRDtRQUNqRCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFBQyxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUFDLENBQUM7UUFDbEQsTUFBTSx1QkFBdUIsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBTyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLFVBQVUsQ0FBQyxDQUFDO1FBQ3BGLHVFQUF1RTtRQUN2RSxJQUFJLHVCQUF1QixDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUFDLE9BQU8sdUJBQXVCLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFBQyxDQUFDO0lBQ2xGLENBQUM7SUFDRCxnREFBZ0Q7SUFDaEQsTUFBTSx1QkFBdUIsR0FBNkIsVUFBaUIsQ0FBQztJQUM1RSxNQUFNLFFBQVEsR0FBRyx1QkFBdUIsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLFVBQW1CLENBQUMsQ0FBQztJQUNwRixPQUFPLFFBQVEsQ0FBQyxZQUFZLENBQUMsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUNuRCxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLEdBQUcsQ0FBYSxVQUFrQixFQUFFLEdBQWlCLEVBQU8sRUFBRTtJQUMzRixNQUFNLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ3JDLE1BQU0sU0FBUyxHQUFVLEVBQUUsQ0FBQztJQUM1QixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBNkIsRUFBRSxFQUFFO1FBQzdDLE1BQU0sUUFBUSxHQUFRLEdBQUcsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLFVBQW1CLENBQUMsQ0FBQztRQUNyRSxRQUFRLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQWEsRUFBRSxFQUFFO1lBQzNDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7Z0JBQ2xDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDM0IsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDLENBQUM7QUFLRixNQUFNLE9BQU8sa0JBQWtCO0lBQzdCO1FBQ0UsT0FBTyxrQkFBa0IsQ0FBVyx3QkFBd0IsQ0FBQyxDQUFDO0lBQ2hFLENBQUM7Q0FDRjtBQUVELE1BQU0sQ0FBQyxNQUFNLHdCQUF3QixHQUFHLFdBQVcsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlcnNpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudENvbnRhaW5lciB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlyZWJhc2VBcHAsIGdldEFwcHMgfSBmcm9tICdmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHR5cGUgeyBBcHBDaGVjayB9IGZyb20gJ2ZpcmViYXNlL2FwcC1jaGVjayc7XG5cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gbmV3IFZlcnNpb24oJ0FOR1VMQVJGSVJFMl9WRVJTSU9OJyk7XG5cbmV4cG9ydCBjb25zdCDJtWlzU3VwcG9ydGVkRXJyb3IgPSAobW9kdWxlOiBzdHJpbmcpID0+XG4gIGBUaGUgQVBQX0lOSVRJQUxJWkVSIHRoYXQgaXMgXCJtYWtpbmdcIiBpc1N1cHBvcnRlZCgpIHN5bmMgZm9yIHRoZSBzYWtlIG9mIGNvbnZlbmllbnQgREkgaGFzIG5vdCByZXNvbHZlZCBpbiB0aGlzXG5jb250ZXh0LiBSYXRoZXIgdGhhbiBpbmplY3RpbmcgJHttb2R1bGV9IGluIHRoZSBjb25zdHJ1Y3RvciwgZmlyc3QgZW5zdXJlIHRoYXQgJHttb2R1bGV9IGlzIHN1cHBvcnRlZCBieSBjYWxsaW5nXG5cXGBhd2FpdCBpc1N1cHBvcnRlZCgpXFxgLCB0aGVuIHJldHJpZXZlIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBpbmplY3RvciBtYW51YWxseSBcXGBpbmplY3Rvci5nZXQoJHttb2R1bGV9KVxcYC5gO1xuXG4vLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBnZXQgYXQgdGhlIGludGVybmFsIHR5cGVzP1xuaW50ZXJmYWNlIEZpcmViYXNlQXBwV2l0aENvbnRhaW5lciBleHRlbmRzIEZpcmViYXNlQXBwIHtcbiAgY29udGFpbmVyOiBDb21wb25lbnRDb250YWluZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiDJtWdldERlZmF1bHRJbnN0YW5jZU9mPFQ9IHVua25vd24+KGlkZW50aWZpZXI6IHN0cmluZywgcHJvdmlkZWQ6IFRbXXx1bmRlZmluZWQsIGRlZmF1bHRBcHA6IEZpcmViYXNlQXBwKTogVHx1bmRlZmluZWQgIHtcbiAgaWYgKHByb3ZpZGVkKSB7XG4gICAgLy8gV2FzIHByb3ZpZGUqIG9ubHkgY2FsbGVkIG9uY2U/IElmIHNvIGdyYWIgdGhhdFxuICAgIGlmIChwcm92aWRlZC5sZW5ndGggPT09IDEpIHsgcmV0dXJuIHByb3ZpZGVkWzBdOyB9XG4gICAgY29uc3QgcHJvdmlkZWRVc2luZ0RlZmF1bHRBcHAgPSBwcm92aWRlZC5maWx0ZXIoKGl0OiBhbnkpID0+IGl0LmFwcCA9PT0gZGVmYXVsdEFwcCk7XG4gICAgLy8gV2FzIHByb3ZpZGUqIG9ubHkgY2FsbGVkIG9uY2UsIHVzaW5nIHRoZSBkZWZhdWx0IGFwcD8gSWYgc28gdXNlIHRoYXRcbiAgICBpZiAocHJvdmlkZWRVc2luZ0RlZmF1bHRBcHAubGVuZ3RoID09PSAxKSB7IHJldHVybiBwcm92aWRlZFVzaW5nRGVmYXVsdEFwcFswXTsgfVxuICB9XG4gIC8vIEdyYWIgdGhlIGRlZmF1bHQgaW5zdGFuY2UgZnJvbSB0aGUgZGVmYXVsdEFwcFxuICBjb25zdCBkZWZhdWx0QXBwV2l0aENvbnRhaW5lcjogRmlyZWJhc2VBcHBXaXRoQ29udGFpbmVyID0gZGVmYXVsdEFwcCBhcyBhbnk7XG4gIGNvbnN0IHByb3ZpZGVyID0gZGVmYXVsdEFwcFdpdGhDb250YWluZXIuY29udGFpbmVyLmdldFByb3ZpZGVyKGlkZW50aWZpZXIgYXMgbmV2ZXIpO1xuICByZXR1cm4gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XG59XG5cbmV4cG9ydCBjb25zdCDJtWdldEFsbEluc3RhbmNlc09mID0gPFQ9IHVua25vd24+KGlkZW50aWZpZXI6IHN0cmluZywgYXBwPzogRmlyZWJhc2VBcHApOiBUW10gPT4ge1xuICBjb25zdCBhcHBzID0gYXBwID8gW2FwcF0gOiBnZXRBcHBzKCk7XG4gIGNvbnN0IGluc3RhbmNlczogYW55W10gPSBbXTtcbiAgYXBwcy5mb3JFYWNoKChhcHA6IEZpcmViYXNlQXBwV2l0aENvbnRhaW5lcikgPT4ge1xuICAgIGNvbnN0IHByb3ZpZGVyOiBhbnkgPSBhcHAuY29udGFpbmVyLmdldFByb3ZpZGVyKGlkZW50aWZpZXIgYXMgbmV2ZXIpO1xuICAgIHByb3ZpZGVyLmluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZTogYW55KSA9PiB7XG4gICAgICBpZiAoIWluc3RhbmNlcy5pbmNsdWRlcyhpbnN0YW5jZSkpIHtcbiAgICAgICAgaW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGluc3RhbmNlcztcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIMm1QXBwQ2hlY2tJbnN0YW5jZXMgZXh0ZW5kcyBBcnJheTxBcHBDaGVjaz4ge31cblxuZXhwb3J0IGNsYXNzIMm1QXBwQ2hlY2tJbnN0YW5jZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICByZXR1cm4gybVnZXRBbGxJbnN0YW5jZXNPZjxBcHBDaGVjaz4oybVBUFBfQ0hFQ0tfUFJPVklERVJfTkFNRSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IMm1QVBQX0NIRUNLX1BST1ZJREVSX05BTUUgPSAnYXBwLWNoZWNrJztcbiJdfQ==