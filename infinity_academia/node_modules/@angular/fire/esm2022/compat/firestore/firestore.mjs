import { isPlatformServer } from '@angular/common';
import { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID } from '@angular/core';
import { ɵAngularFireSchedulers } from '@angular/fire';
import { AppCheckInstances } from '@angular/fire/app-check';
import { FIREBASE_APP_NAME, FIREBASE_OPTIONS, ɵcacheInstance, ɵfirebaseAppFactory } from '@angular/fire/compat';
import { SETTINGS as AUTH_SETTINGS, AngularFireAuth, LANGUAGE_CODE, PERSISTENCE, TENANT_ID, USE_EMULATOR as USE_AUTH_EMULATOR, USE_DEVICE_LANGUAGE, ɵauthFactory, } from '@angular/fire/compat/auth';
import { from, of } from 'rxjs';
import { AngularFirestoreCollection } from './collection/collection';
import { AngularFirestoreCollectionGroup } from './collection-group/collection-group';
import { AngularFirestoreDocument } from './document/document';
import 'firebase/compat/auth';
import 'firebase/compat/firestore';
import * as i0 from "@angular/core";
import * as i1 from "@angular/fire";
import * as i2 from "@angular/fire/compat/auth";
import * as i3 from "@angular/fire/app-check";
/**
 * The value of this token determines whether or not the firestore will have persistance enabled
 */
export const ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');
export const PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');
export const SETTINGS = new InjectionToken('angularfire2.firestore.settings');
export const USE_EMULATOR = new InjectionToken('angularfire2.firestore.use-emulator');
/**
 * A utility methods for associating a collection reference with
 * a query.
 *
 * @param collectionRef - A collection reference to query
 * @param queryFn - The callback to create a query
 *
 * Example:
 * const { query, ref } = associateQuery(docRef.collection('items'), ref => {
 *  return ref.where('age', '<', 200);
 * });
 */
export function associateQuery(collectionRef, queryFn = ref => ref) {
    const query = queryFn(collectionRef);
    const ref = collectionRef;
    return { query, ref };
}
/**
 * AngularFirestore Service
 *
 * This service is the main entry point for this feature module. It provides
 * an API for creating Collection and Reference services. These services can
 * then be used to do data updates and observable streams of the data.
 *
 * Example:
 *
 * import { Component } from '@angular/core';
 * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';
 * import { Observable } from 'rxjs/Observable';
 * import { from } from 'rxjs/observable';
 *
 * @Component({
 *   selector: 'app-my-component',
 *   template: `
 *    <h2>Items for {{ (profile | async)?.name }}
 *    <ul>
 *       <li *ngFor="let item of items | async">{{ item.name }}</li>
 *    </ul>
 *    <div class="control-input">
 *       <input type="text" #itemname />
 *       <button (click)="addItem(itemname.value)">Add Item</button>
 *    </div>
 *   `
 * })
 * export class MyComponent implements OnInit {
 *
 *   // services for data operations and data streaming
 *   private readonly itemsRef: AngularFirestoreCollection<Item>;
 *   private readonly profileRef: AngularFirestoreDocument<Profile>;
 *
 *   // observables for template
 *   items: Observable<Item[]>;
 *   profile: Observable<Profile>;
 *
 *   // inject main service
 *   constructor(private readonly afs: AngularFirestore) {}
 *
 *   ngOnInit() {
 *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));
 *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));
 *     // this.items = from(this.itemsRef); // you can also do this with no mapping
 *
 *     this.profileRef = afs.doc('users/davideast');
 *     this.profile = this.profileRef.valueChanges();
 *   }
 *
 *   addItem(name: string) {
 *     const user = 'davideast';
 *     this.itemsRef.add({ name, user });
 *   }
 * }
 */
export class AngularFirestore {
    schedulers;
    firestore;
    persistenceEnabled$;
    /**
     * Each Feature of AngularFire has a FirebaseApp injected. This way we
     * don't rely on the main Firebase App instance and we can create named
     * apps and use multiple apps.
     */
    constructor(options, name, shouldEnablePersistence, settings, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    platformId, zone, schedulers, persistenceSettings, _useEmulator, auth, useAuthEmulator, authSettings, // can't use firebase.auth.AuthSettings here
    tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {
        this.schedulers = schedulers;
        const app = ɵfirebaseAppFactory(options, zone, name);
        const useEmulator = _useEmulator;
        if (auth) {
            ɵauthFactory(app, zone, useAuthEmulator, tenantId, languageCode, useDeviceLanguage, authSettings, persistence);
        }
        [this.firestore, this.persistenceEnabled$] = ɵcacheInstance(`${app.name}.firestore`, 'AngularFirestore', app.name, () => {
            const firestore = zone.runOutsideAngular(() => app.firestore());
            if (settings) {
                firestore.settings(settings);
            }
            if (useEmulator) {
                firestore.useEmulator(...useEmulator);
            }
            if (shouldEnablePersistence && !isPlatformServer(platformId)) {
                // We need to try/catch here because not all enablePersistence() failures are caught
                // https://github.com/firebase/firebase-js-sdk/issues/608
                const enablePersistence = () => {
                    try {
                        return from(firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));
                    }
                    catch (e) {
                        if (typeof console !== 'undefined') {
                            console.warn(e);
                        }
                        return of(false);
                    }
                };
                return [firestore, zone.runOutsideAngular(enablePersistence)];
            }
            else {
                return [firestore, of(false)];
            }
        }, [settings, useEmulator, shouldEnablePersistence]);
    }
    collection(pathOrRef, queryFn) {
        let collectionRef;
        if (typeof pathOrRef === 'string') {
            collectionRef = this.firestore.collection(pathOrRef);
        }
        else {
            collectionRef = pathOrRef;
        }
        const { ref, query } = associateQuery(collectionRef, queryFn);
        const refInZone = this.schedulers.ngZone.run(() => ref);
        return new AngularFirestoreCollection(refInZone, query, this);
    }
    /**
     * Create a reference to a Firestore Collection Group based on a collectionId
     * and an optional query function to narrow the result
     * set.
     */
    collectionGroup(collectionId, queryGroupFn) {
        const queryFn = queryGroupFn || (ref => ref);
        const collectionGroup = this.firestore.collectionGroup(collectionId);
        return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);
    }
    doc(pathOrRef) {
        let ref;
        if (typeof pathOrRef === 'string') {
            ref = this.firestore.doc(pathOrRef);
        }
        else {
            ref = pathOrRef;
        }
        const refInZone = this.schedulers.ngZone.run(() => ref);
        return new AngularFirestoreDocument(refInZone, this);
    }
    /**
     * Returns a generated Firestore Document Id.
     */
    createId() {
        return this.firestore.collection('_').doc().id;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: AngularFirestore, deps: [{ token: FIREBASE_OPTIONS }, { token: FIREBASE_APP_NAME, optional: true }, { token: ENABLE_PERSISTENCE, optional: true }, { token: SETTINGS, optional: true }, { token: PLATFORM_ID }, { token: i0.NgZone }, { token: i1.ɵAngularFireSchedulers }, { token: PERSISTENCE_SETTINGS, optional: true }, { token: USE_EMULATOR, optional: true }, { token: i2.AngularFireAuth, optional: true }, { token: USE_AUTH_EMULATOR, optional: true }, { token: AUTH_SETTINGS, optional: true }, { token: TENANT_ID, optional: true }, { token: LANGUAGE_CODE, optional: true }, { token: USE_DEVICE_LANGUAGE, optional: true }, { token: PERSISTENCE, optional: true }, { token: i3.AppCheckInstances, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: AngularFirestore, providedIn: 'any' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: AngularFirestore, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'any'
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [FIREBASE_OPTIONS]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [FIREBASE_APP_NAME]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [ENABLE_PERSISTENCE]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [SETTINGS]
                }] }, { type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: i0.NgZone }, { type: i1.ɵAngularFireSchedulers }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [PERSISTENCE_SETTINGS]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [USE_EMULATOR]
                }] }, { type: i2.AngularFireAuth, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [USE_AUTH_EMULATOR]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [AUTH_SETTINGS]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TENANT_ID]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [LANGUAGE_CODE]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [USE_DEVICE_LANGUAGE]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [PERSISTENCE]
                }] }, { type: i3.AppCheckInstances, decorators: [{
                    type: Optional
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlyZXN0b3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2NvbXBhdC9maXJlc3RvcmUvZmlyZXN0b3JlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNsRyxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdkQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDNUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLGdCQUFnQixFQUFFLGNBQWMsRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2hILE9BQU8sRUFDTCxRQUFRLElBQUksYUFBYSxFQUN6QixlQUFlLEVBQ2YsYUFBYSxFQUNiLFdBQVcsRUFDWCxTQUFTLEVBQ1QsWUFBWSxJQUFJLGlCQUFpQixFQUNqQyxtQkFBbUIsRUFDbkIsWUFBWSxHQUNiLE1BQU0sMkJBQTJCLENBQUM7QUFHbkMsT0FBTyxFQUFjLElBQUksRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUMsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDckUsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDdEYsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFXL0QsT0FBTyxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLDJCQUEyQixDQUFDOzs7OztBQUVuQzs7R0FFRztBQUNILE1BQU0sQ0FBQyxNQUFNLGtCQUFrQixHQUFHLElBQUksY0FBYyxDQUFVLHlDQUF5QyxDQUFDLENBQUM7QUFDekcsTUFB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QUFDLGdCQUFnQjs7MEJBQ3ZCLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMsaUJBQWlCOzswQkFDcEMsUUFBUTs7MEJBQUksTUFBTTsyQkFBQyxrQkFBa0I7OzBCQUNyQyxRQUFROzswQkFBSSxNQUFNOzJCQUFDLFFBQVE7OzBCQUUzQixNQUFNOzJCQUFDLFdBQVc7OzBCQUdsQixRQUFROzswQkFBSSxNQUFNOzJCQUFDLG9CQUFvQjs7MEJBQ3ZDLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMsWUFBWTs7MEJBQy9CLFFBQVE7OzBCQUNSLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMsaUJBQWlCOzswQkFDcEMsUUFBUTs7MEJBQUksTUFBTTsyQkFBQyxhQUFhOzswQkFDaEMsUUFBUTs7MEJBQUksTUFBTTsyQkFBQyxTQUFTOzswQkFDNUIsUUFBUTs7MEJBQUksTUFBTTsyQkFBQyxhQUFhOzswQkFDaEMsUUFBUTs7MEJBQUksTUFBTTsyQkFBQyxtQkFBbUI7OzBCQUN0QyxRQUFROzswQkFBSSxNQUFNOzJCQUFDLFdBQVc7OzBCQUM5QixRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQbGF0Zm9ybVNlcnZlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBOZ1pvbmUsIE9wdGlvbmFsLCBQTEFURk9STV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMgfSBmcm9tICdAYW5ndWxhci9maXJlJztcbmltcG9ydCB7IEFwcENoZWNrSW5zdGFuY2VzIH0gZnJvbSAnQGFuZ3VsYXIvZmlyZS9hcHAtY2hlY2snO1xuaW1wb3J0IHsgRklSRUJBU0VfQVBQX05BTUUsIEZJUkVCQVNFX09QVElPTlMsIMm1Y2FjaGVJbnN0YW5jZSwgybVmaXJlYmFzZUFwcEZhY3RvcnkgfSBmcm9tICdAYW5ndWxhci9maXJlL2NvbXBhdCc7XG5pbXBvcnQge1xuICBTRVRUSU5HUyBhcyBBVVRIX1NFVFRJTkdTLFxuICBBbmd1bGFyRmlyZUF1dGgsXG4gIExBTkdVQUdFX0NPREUsXG4gIFBFUlNJU1RFTkNFLFxuICBURU5BTlRfSUQsXG4gIFVTRV9FTVVMQVRPUiBhcyBVU0VfQVVUSF9FTVVMQVRPUixcbiAgVVNFX0RFVklDRV9MQU5HVUFHRSxcbiAgybVhdXRoRmFjdG9yeSxcbn0gZnJvbSAnQGFuZ3VsYXIvZmlyZS9jb21wYXQvYXV0aCc7XG5pbXBvcnQgeyBGaXJlYmFzZU9wdGlvbnMgfSBmcm9tICdmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlL2NvbXBhdC9hcHAnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZnJvbSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uIH0gZnJvbSAnLi9jb2xsZWN0aW9uL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb25Hcm91cCB9IGZyb20gJy4vY29sbGVjdGlvbi1ncm91cC9jb2xsZWN0aW9uLWdyb3VwJztcbmltcG9ydCB7IEFuZ3VsYXJGaXJlc3RvcmVEb2N1bWVudCB9IGZyb20gJy4vZG9jdW1lbnQvZG9jdW1lbnQnO1xuaW1wb3J0IHtcbiAgQXNzb2NpYXRlZFJlZmVyZW5jZSxcbiAgQ29sbGVjdGlvblJlZmVyZW5jZSxcbiAgRG9jdW1lbnRSZWZlcmVuY2UsXG4gIFBlcnNpc3RlbmNlU2V0dGluZ3MsXG4gIFF1ZXJ5LFxuICBRdWVyeUZuLFxuICBRdWVyeUdyb3VwRm4sXG4gIFNldHRpbmdzXG59IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgJ2ZpcmViYXNlL2NvbXBhdC9hdXRoJztcbmltcG9ydCAnZmlyZWJhc2UvY29tcGF0L2ZpcmVzdG9yZSc7XG5cbi8qKlxuICogVGhlIHZhbHVlIG9mIHRoaXMgdG9rZW4gZGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgZmlyZXN0b3JlIHdpbGwgaGF2ZSBwZXJzaXN0YW5jZSBlbmFibGVkXG4gKi9cbmV4cG9ydCBjb25zdCBFTkFCTEVfUEVSU0lTVEVOQ0UgPSBuZXcgSW5qZWN0aW9uVG9rZW48Ym9vbGVhbj4oJ2FuZ3VsYXJmaXJlMi5lbmFibGVGaXJlc3RvcmVQZXJzaXN0ZW5jZScpO1xuZXhwb3J0IGNvbnN0IFBFUlNJU1RFTkNFX1NFVFRJTkdTID0gbmV3IEluamVjdGlvblRva2VuPFBlcnNpc3RlbmNlU2V0dGluZ3MgfCB1bmRlZmluZWQ+KCdhbmd1bGFyZmlyZTIuZmlyZXN0b3JlLnBlcnNpc3RlbmNlU2V0dGluZ3MnKTtcbmV4cG9ydCBjb25zdCBTRVRUSU5HUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxTZXR0aW5ncz4oJ2FuZ3VsYXJmaXJlMi5maXJlc3RvcmUuc2V0dGluZ3MnKTtcblxudHlwZSBVc2VFbXVsYXRvckFyZ3VtZW50cyA9IFBhcmFtZXRlcnM8ZmlyZWJhc2UuZmlyZXN0b3JlLkZpcmVzdG9yZVsndXNlRW11bGF0b3InXT47XG5leHBvcnQgY29uc3QgVVNFX0VNVUxBVE9SID0gbmV3IEluamVjdGlvblRva2VuPFVzZUVtdWxhdG9yQXJndW1lbnRzPignYW5ndWxhcmZpcmUyLmZpcmVzdG9yZS51c2UtZW11bGF0b3InKTtcblxuLyoqXG4gKiBBIHV0aWxpdHkgbWV0aG9kcyBmb3IgYXNzb2NpYXRpbmcgYSBjb2xsZWN0aW9uIHJlZmVyZW5jZSB3aXRoXG4gKiBhIHF1ZXJ5LlxuICpcbiAqIEBwYXJhbSBjb2xsZWN0aW9uUmVmIC0gQSBjb2xsZWN0aW9uIHJlZmVyZW5jZSB0byBxdWVyeVxuICogQHBhcmFtIHF1ZXJ5Rm4gLSBUaGUgY2FsbGJhY2sgdG8gY3JlYXRlIGEgcXVlcnlcbiAqXG4gKiBFeGFtcGxlOlxuICogY29uc3QgeyBxdWVyeSwgcmVmIH0gPSBhc3NvY2lhdGVRdWVyeShkb2NSZWYuY29sbGVjdGlvbignaXRlbXMnKSwgcmVmID0+IHtcbiAqICByZXR1cm4gcmVmLndoZXJlKCdhZ2UnLCAnPCcsIDIwMCk7XG4gKiB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc29jaWF0ZVF1ZXJ5PFQ+KGNvbGxlY3Rpb25SZWY6IENvbGxlY3Rpb25SZWZlcmVuY2U8VD4sIHF1ZXJ5Rm4gPSByZWYgPT4gcmVmKTogQXNzb2NpYXRlZFJlZmVyZW5jZTxUPiB7XG4gIGNvbnN0IHF1ZXJ5ID0gcXVlcnlGbihjb2xsZWN0aW9uUmVmKTtcbiAgY29uc3QgcmVmID0gY29sbGVjdGlvblJlZjtcbiAgcmV0dXJuIHsgcXVlcnksIHJlZiB9O1xufVxuXG4vKipcbiAqIEFuZ3VsYXJGaXJlc3RvcmUgU2VydmljZVxuICpcbiAqIFRoaXMgc2VydmljZSBpcyB0aGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgdGhpcyBmZWF0dXJlIG1vZHVsZS4gSXQgcHJvdmlkZXNcbiAqIGFuIEFQSSBmb3IgY3JlYXRpbmcgQ29sbGVjdGlvbiBhbmQgUmVmZXJlbmNlIHNlcnZpY2VzLiBUaGVzZSBzZXJ2aWNlcyBjYW5cbiAqIHRoZW4gYmUgdXNlZCB0byBkbyBkYXRhIHVwZGF0ZXMgYW5kIG9ic2VydmFibGUgc3RyZWFtcyBvZiB0aGUgZGF0YS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgQW5ndWxhckZpcmVzdG9yZSwgQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb24sIEFuZ3VsYXJGaXJlc3RvcmVEb2N1bWVudCB9IGZyb20gJ0Bhbmd1bGFyL2ZpcmUvZmlyZXN0b3JlJztcbiAqIGltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuICogaW1wb3J0IHsgZnJvbSB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZSc7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnYXBwLW15LWNvbXBvbmVudCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICA8aDI+SXRlbXMgZm9yIHt7IChwcm9maWxlIHwgYXN5bmMpPy5uYW1lIH19XG4gKiAgICA8dWw+XG4gKiAgICAgICA8bGkgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXMgfCBhc3luY1wiPnt7IGl0ZW0ubmFtZSB9fTwvbGk+XG4gKiAgICA8L3VsPlxuICogICAgPGRpdiBjbGFzcz1cImNvbnRyb2wtaW5wdXRcIj5cbiAqICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiICNpdGVtbmFtZSAvPlxuICogICAgICAgPGJ1dHRvbiAoY2xpY2spPVwiYWRkSXRlbShpdGVtbmFtZS52YWx1ZSlcIj5BZGQgSXRlbTwvYnV0dG9uPlxuICogICAgPC9kaXY+XG4gKiAgIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICpcbiAqICAgLy8gc2VydmljZXMgZm9yIGRhdGEgb3BlcmF0aW9ucyBhbmQgZGF0YSBzdHJlYW1pbmdcbiAqICAgcHJpdmF0ZSByZWFkb25seSBpdGVtc1JlZjogQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb248SXRlbT47XG4gKiAgIHByaXZhdGUgcmVhZG9ubHkgcHJvZmlsZVJlZjogQW5ndWxhckZpcmVzdG9yZURvY3VtZW50PFByb2ZpbGU+O1xuICpcbiAqICAgLy8gb2JzZXJ2YWJsZXMgZm9yIHRlbXBsYXRlXG4gKiAgIGl0ZW1zOiBPYnNlcnZhYmxlPEl0ZW1bXT47XG4gKiAgIHByb2ZpbGU6IE9ic2VydmFibGU8UHJvZmlsZT47XG4gKlxuICogICAvLyBpbmplY3QgbWFpbiBzZXJ2aWNlXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYWZzOiBBbmd1bGFyRmlyZXN0b3JlKSB7fVxuICpcbiAqICAgbmdPbkluaXQoKSB7XG4gKiAgICAgdGhpcy5pdGVtc1JlZiA9IGFmcy5jb2xsZWN0aW9uKCdpdGVtcycsIHJlZiA9PiByZWYud2hlcmUoJ3VzZXInLCAnPT0nLCAnZGF2aWRlYXN0JykubGltaXQoMTApKTtcbiAqICAgICB0aGlzLml0ZW1zID0gdGhpcy5pdGVtc1JlZi52YWx1ZUNoYW5nZXMoKS5tYXAoc25hcCA9PiBzbmFwLmRvY3MubWFwKGRhdGEgPT4gZG9jLmRhdGEoKSkpO1xuICogICAgIC8vIHRoaXMuaXRlbXMgPSBmcm9tKHRoaXMuaXRlbXNSZWYpOyAvLyB5b3UgY2FuIGFsc28gZG8gdGhpcyB3aXRoIG5vIG1hcHBpbmdcbiAqXG4gKiAgICAgdGhpcy5wcm9maWxlUmVmID0gYWZzLmRvYygndXNlcnMvZGF2aWRlYXN0Jyk7XG4gKiAgICAgdGhpcy5wcm9maWxlID0gdGhpcy5wcm9maWxlUmVmLnZhbHVlQ2hhbmdlcygpO1xuICogICB9XG4gKlxuICogICBhZGRJdGVtKG5hbWU6IHN0cmluZykge1xuICogICAgIGNvbnN0IHVzZXIgPSAnZGF2aWRlYXN0JztcbiAqICAgICB0aGlzLml0ZW1zUmVmLmFkZCh7IG5hbWUsIHVzZXIgfSk7XG4gKiAgIH1cbiAqIH1cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAnYW55J1xufSlcbmV4cG9ydCBjbGFzcyBBbmd1bGFyRmlyZXN0b3JlIHtcbiAgcHVibGljIHJlYWRvbmx5IGZpcmVzdG9yZTogZmlyZWJhc2UuZmlyZXN0b3JlLkZpcmVzdG9yZTtcbiAgcHVibGljIHJlYWRvbmx5IHBlcnNpc3RlbmNlRW5hYmxlZCQ6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIEVhY2ggRmVhdHVyZSBvZiBBbmd1bGFyRmlyZSBoYXMgYSBGaXJlYmFzZUFwcCBpbmplY3RlZC4gVGhpcyB3YXkgd2VcbiAgICogZG9uJ3QgcmVseSBvbiB0aGUgbWFpbiBGaXJlYmFzZSBBcHAgaW5zdGFuY2UgYW5kIHdlIGNhbiBjcmVhdGUgbmFtZWRcbiAgICogYXBwcyBhbmQgdXNlIG11bHRpcGxlIGFwcHMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KEZJUkVCQVNFX09QVElPTlMpIG9wdGlvbnM6IEZpcmViYXNlT3B0aW9ucyxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KEZJUkVCQVNFX0FQUF9OQU1FKSBuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRU5BQkxFX1BFUlNJU1RFTkNFKSBzaG91bGRFbmFibGVQZXJzaXN0ZW5jZTogYm9vbGVhbiB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChTRVRUSU5HUykgc2V0dGluZ3M6IFNldHRpbmdzIHwgbnVsbCxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHBsYXRmb3JtSWQ6IE9iamVjdCxcbiAgICB6b25lOiBOZ1pvbmUsXG4gICAgcHVibGljIHNjaGVkdWxlcnM6IMm1QW5ndWxhckZpcmVTY2hlZHVsZXJzLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoUEVSU0lTVEVOQ0VfU0VUVElOR1MpIHBlcnNpc3RlbmNlU2V0dGluZ3M6IFBlcnNpc3RlbmNlU2V0dGluZ3MgfCBudWxsLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoVVNFX0VNVUxBVE9SKSBfdXNlRW11bGF0b3I6IGFueSxcbiAgICBAT3B0aW9uYWwoKSBhdXRoOiBBbmd1bGFyRmlyZUF1dGgsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChVU0VfQVVUSF9FTVVMQVRPUikgdXNlQXV0aEVtdWxhdG9yOiBhbnksXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChBVVRIX1NFVFRJTkdTKSBhdXRoU2V0dGluZ3M6IGFueSwgLy8gY2FuJ3QgdXNlIGZpcmViYXNlLmF1dGguQXV0aFNldHRpbmdzIGhlcmVcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFRFTkFOVF9JRCkgdGVuYW50SWQ6IHN0cmluZyB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChMQU5HVUFHRV9DT0RFKSBsYW5ndWFnZUNvZGU6IHN0cmluZyB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChVU0VfREVWSUNFX0xBTkdVQUdFKSB1c2VEZXZpY2VMYW5ndWFnZTogYm9vbGVhbiB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChQRVJTSVNURU5DRSkgcGVyc2lzdGVuY2U6IHN0cmluZyB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgX2FwcENoZWNrSW5zdGFuY2VzOiBBcHBDaGVja0luc3RhbmNlcyxcbiAgKSB7XG4gICAgY29uc3QgYXBwID0gybVmaXJlYmFzZUFwcEZhY3Rvcnkob3B0aW9ucywgem9uZSwgbmFtZSk7XG4gICAgY29uc3QgdXNlRW11bGF0b3I6IFVzZUVtdWxhdG9yQXJndW1lbnRzIHwgbnVsbCA9IF91c2VFbXVsYXRvcjtcblxuICAgIGlmIChhdXRoKSB7XG4gICAgICDJtWF1dGhGYWN0b3J5KGFwcCwgem9uZSwgdXNlQXV0aEVtdWxhdG9yLCB0ZW5hbnRJZCwgbGFuZ3VhZ2VDb2RlLCB1c2VEZXZpY2VMYW5ndWFnZSwgYXV0aFNldHRpbmdzLCBwZXJzaXN0ZW5jZSk7XG4gICAgfVxuXG4gICAgW3RoaXMuZmlyZXN0b3JlLCB0aGlzLnBlcnNpc3RlbmNlRW5hYmxlZCRdID0gybVjYWNoZUluc3RhbmNlKGAke2FwcC5uYW1lfS5maXJlc3RvcmVgLCAnQW5ndWxhckZpcmVzdG9yZScsIGFwcC5uYW1lLCAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJlc3RvcmUgPSB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IGFwcC5maXJlc3RvcmUoKSk7XG4gICAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgICAgZmlyZXN0b3JlLnNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgIH1cbiAgICAgIGlmICh1c2VFbXVsYXRvcikge1xuICAgICAgICBmaXJlc3RvcmUudXNlRW11bGF0b3IoLi4udXNlRW11bGF0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkRW5hYmxlUGVyc2lzdGVuY2UgJiYgIWlzUGxhdGZvcm1TZXJ2ZXIocGxhdGZvcm1JZCkpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB0cnkvY2F0Y2ggaGVyZSBiZWNhdXNlIG5vdCBhbGwgZW5hYmxlUGVyc2lzdGVuY2UoKSBmYWlsdXJlcyBhcmUgY2F1Z2h0XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzYwOFxuICAgICAgICBjb25zdCBlbmFibGVQZXJzaXN0ZW5jZSA9ICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb20oZmlyZXN0b3JlLmVuYWJsZVBlcnNpc3RlbmNlKHBlcnNpc3RlbmNlU2V0dGluZ3MgfHwgdW5kZWZpbmVkKS50aGVuKCgpID0+IHRydWUsICgpID0+IGZhbHNlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykgeyBjb25zb2xlLndhcm4oZSk7IH1cbiAgICAgICAgICAgIHJldHVybiBvZihmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gW2ZpcmVzdG9yZSwgem9uZS5ydW5PdXRzaWRlQW5ndWxhcihlbmFibGVQZXJzaXN0ZW5jZSldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtmaXJlc3RvcmUsIG9mKGZhbHNlKV07XG4gICAgICB9XG5cbiAgICB9LCBbc2V0dGluZ3MsIHVzZUVtdWxhdG9yLCBzaG91bGRFbmFibGVQZXJzaXN0ZW5jZV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlZmVyZW5jZSB0byBhIEZpcmVzdG9yZSBDb2xsZWN0aW9uIGJhc2VkIG9uIGEgcGF0aCBvclxuICAgKiBDb2xsZWN0aW9uUmVmZXJlbmNlIGFuZCBhbiBvcHRpb25hbCBxdWVyeSBmdW5jdGlvbiB0byBuYXJyb3cgdGhlIHJlc3VsdFxuICAgKiBzZXQuXG4gICAqL1xuICBjb2xsZWN0aW9uPFQ+KHBhdGg6IHN0cmluZywgcXVlcnlGbj86IFF1ZXJ5Rm4pOiBBbmd1bGFyRmlyZXN0b3JlQ29sbGVjdGlvbjxUPjtcbiAgY29sbGVjdGlvbjxUPihyZWY6IENvbGxlY3Rpb25SZWZlcmVuY2UsIHF1ZXJ5Rm4/OiBRdWVyeUZuKTogQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb248VD47XG4gIGNvbGxlY3Rpb248VD4ocGF0aE9yUmVmOiBzdHJpbmcgfCBDb2xsZWN0aW9uUmVmZXJlbmNlPFQ+LCBxdWVyeUZuPzogUXVlcnlGbik6IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uPFQ+IHtcbiAgICBsZXQgY29sbGVjdGlvblJlZjogQ29sbGVjdGlvblJlZmVyZW5jZTxUPjtcbiAgICBpZiAodHlwZW9mIHBhdGhPclJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbGxlY3Rpb25SZWYgPSB0aGlzLmZpcmVzdG9yZS5jb2xsZWN0aW9uKHBhdGhPclJlZikgYXMgZmlyZWJhc2UuZmlyZXN0b3JlLkNvbGxlY3Rpb25SZWZlcmVuY2U8VD47XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbGxlY3Rpb25SZWYgPSBwYXRoT3JSZWY7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVmLCBxdWVyeSB9ID0gYXNzb2NpYXRlUXVlcnk8VD4oY29sbGVjdGlvblJlZiwgcXVlcnlGbik7XG4gICAgY29uc3QgcmVmSW5ab25lID0gdGhpcy5zY2hlZHVsZXJzLm5nWm9uZS5ydW4oKCkgPT4gcmVmKTtcbiAgICByZXR1cm4gbmV3IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uPFQ+KHJlZkluWm9uZSwgcXVlcnksIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlZmVyZW5jZSB0byBhIEZpcmVzdG9yZSBDb2xsZWN0aW9uIEdyb3VwIGJhc2VkIG9uIGEgY29sbGVjdGlvbklkXG4gICAqIGFuZCBhbiBvcHRpb25hbCBxdWVyeSBmdW5jdGlvbiB0byBuYXJyb3cgdGhlIHJlc3VsdFxuICAgKiBzZXQuXG4gICAqL1xuICBjb2xsZWN0aW9uR3JvdXA8VD4oY29sbGVjdGlvbklkOiBzdHJpbmcsIHF1ZXJ5R3JvdXBGbj86IFF1ZXJ5R3JvdXBGbjxUPik6IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uR3JvdXA8VD4ge1xuICAgIGNvbnN0IHF1ZXJ5Rm4gPSBxdWVyeUdyb3VwRm4gfHwgKHJlZiA9PiByZWYpO1xuICAgIGNvbnN0IGNvbGxlY3Rpb25Hcm91cDogUXVlcnk8VD4gPSB0aGlzLmZpcmVzdG9yZS5jb2xsZWN0aW9uR3JvdXAoY29sbGVjdGlvbklkKSBhcyBmaXJlYmFzZS5maXJlc3RvcmUuUXVlcnk8VD47XG4gICAgcmV0dXJuIG5ldyBBbmd1bGFyRmlyZXN0b3JlQ29sbGVjdGlvbkdyb3VwPFQ+KHF1ZXJ5Rm4oY29sbGVjdGlvbkdyb3VwKSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmVmZXJlbmNlIHRvIGEgRmlyZXN0b3JlIERvY3VtZW50IGJhc2VkIG9uIGEgcGF0aCBvclxuICAgKiBEb2N1bWVudFJlZmVyZW5jZS4gTm90ZSB0aGF0IGRvY3VtZW50cyBhcmUgbm90IHF1ZXJ5YWJsZSBiZWNhdXNlIHRoZXkgYXJlXG4gICAqIHNpbXBseSBvYmplY3RzLiBIb3dldmVyLCBkb2N1bWVudHMgaGF2ZSBzdWItY29sbGVjdGlvbnMgdGhhdCByZXR1cm4gYVxuICAgKiBDb2xsZWN0aW9uIHJlZmVyZW5jZSBhbmQgY2FuIGJlIHF1ZXJpZWQuXG4gICAqL1xuICBkb2M8VD4ocGF0aDogc3RyaW5nKTogQW5ndWxhckZpcmVzdG9yZURvY3VtZW50PFQ+O1xuICBkb2M8VD4ocmVmOiBEb2N1bWVudFJlZmVyZW5jZSk6IEFuZ3VsYXJGaXJlc3RvcmVEb2N1bWVudDxUPjtcbiAgZG9jPFQ+KHBhdGhPclJlZjogc3RyaW5nIHwgRG9jdW1lbnRSZWZlcmVuY2U8VD4pOiBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8VD4ge1xuICAgIGxldCByZWY6IERvY3VtZW50UmVmZXJlbmNlPFQ+O1xuICAgIGlmICh0eXBlb2YgcGF0aE9yUmVmID09PSAnc3RyaW5nJykge1xuICAgICAgcmVmID0gdGhpcy5maXJlc3RvcmUuZG9jKHBhdGhPclJlZikgYXMgZmlyZWJhc2UuZmlyZXN0b3JlLkRvY3VtZW50UmVmZXJlbmNlPFQ+O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSBwYXRoT3JSZWY7XG4gICAgfVxuICAgIGNvbnN0IHJlZkluWm9uZSA9IHRoaXMuc2NoZWR1bGVycy5uZ1pvbmUucnVuKCgpID0+IHJlZik7XG4gICAgcmV0dXJuIG5ldyBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8VD4ocmVmSW5ab25lLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZ2VuZXJhdGVkIEZpcmVzdG9yZSBEb2N1bWVudCBJZC5cbiAgICovXG4gIGNyZWF0ZUlkKCkge1xuICAgIHJldHVybiB0aGlzLmZpcmVzdG9yZS5jb2xsZWN0aW9uKCdfJykuZG9jKCkuaWQ7XG4gIH1cbn1cbiJdfQ==