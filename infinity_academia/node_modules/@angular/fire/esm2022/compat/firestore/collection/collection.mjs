import { keepUnstableUntilFirst } from '@angular/fire';
import { from } from 'rxjs';
import { filter, map, pairwise, scan, startWith } from 'rxjs/operators';
import { AngularFirestoreDocument } from '../document/document';
import { fromCollectionRef } from '../observable/fromRef';
import { docChanges, sortedChanges } from './changes';
export function validateEventsArray(events) {
    if (!events || events.length === 0) {
        events = ['added', 'removed', 'modified'];
    }
    return events;
}
/**
 * AngularFirestoreCollection service
 *
 * This class creates a reference to a Firestore Collection. A reference and a query are provided in
 * in the constructor. The query can be the unqueried reference if no query is desired.The class
 * is generic which gives you type safety for data update methods and data streaming.
 *
 * This class uses Symbol.observable to transform into Observable using Observable.from().
 *
 * This class is rarely used directly and should be created from the AngularFirestore service.
 *
 * Example:
 *
 * const collectionRef = firebase.firestore.collection('stocks');
 * const query = collectionRef.where('price', '>', '0.01');
 * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);
 *
 * // NOTE!: the updates are performed on the reference not the query
 * await fakeStock.add({ name: 'FAKE', price: 0.01 });
 *
 * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.
 * fakeStock.valueChanges().subscribe(value => console.log(value));
 */
export class AngularFirestoreCollection {
    ref;
    query;
    afs;
    /**
     * The constructor takes in a CollectionReference and Query to provide wrapper methods
     * for data operations and data streaming.
     *
     * Note: Data operation methods are done on the reference not the query. This means
     * when you update data it is not updating data to the window of your query unless
     * the data fits the criteria of the query. See the AssociatedRefence type for details
     * on this implication.
     */
    constructor(ref, query, afs) {
        this.ref = ref;
        this.query = query;
        this.afs = afs;
    }
    /**
     * Listen to the latest change in the stream. This method returns changes
     * as they occur and they are not sorted by query order. This allows you to construct
     * your own data structure.
     */
    stateChanges(events) {
        let source = docChanges(this.query, this.afs.schedulers.outsideAngular);
        if (events && events.length > 0) {
            source = source.pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)));
        }
        return source.pipe(
        // We want to filter out empty arrays, but always emit at first, so the developer knows
        // that the collection has been resolve; even if it's empty
        startWith(undefined), pairwise(), filter(([prior, current]) => current.length > 0 || !prior), map(([, current]) => current), keepUnstableUntilFirst);
    }
    /**
     * Create a stream of changes as they occur it time. This method is similar to stateChanges()
     * but it collects each event in an array over time.
     */
    auditTrail(events) {
        return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));
    }
    /**
     * Create a stream of synchronized changes. This method keeps the local array in sorted
     * query order.
     */
    snapshotChanges(events) {
        const validatedEvents = validateEventsArray(events);
        const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);
        return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);
    }
    valueChanges(options = {}) {
        return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular)
            .pipe(map(actions => actions.payload.docs.map(a => {
            if (options.idField) {
                return {
                    ...a.data(),
                    ...{ [options.idField]: a.id }
                };
            }
            else {
                return a.data();
            }
        })), keepUnstableUntilFirst);
    }
    /**
     * Retrieve the results of the query once.
     */
    get(options) {
        return from(this.query.get(options)).pipe(keepUnstableUntilFirst);
    }
    /**
     * Add data to a collection reference.
     *
     * Note: Data operation methods are done on the reference not the query. This means
     * when you update data it is not updating data to the window of your query unless
     * the data fits the criteria of the query.
     */
    add(data) {
        return this.ref.add(data);
    }
    /**
     * Create a reference to a single document in a collection.
     */
    doc(path) {
        // TODO is there a better way to solve this type issue
        return new AngularFirestoreDocument(this.ref.doc(path), this.afs);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9jb21wYXQvZmlyZXN0b3JlL2NvbGxlY3Rpb24vY29sbGVjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFdkQsT0FBTyxFQUFjLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN4QyxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hFLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBR2hFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzFELE9BQU8sRUFBRSxVQUFVLEVBQUUsYUFBYSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBSXRELE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxNQUE2QjtJQUMvRCxJQUFJLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDbkMsTUFBTSxHQUFHLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBc0JHO0FBQ0gsTUFBTSxPQUFPLDBCQUEwQjtJQVduQjtJQUNDO0lBQ0E7SUFabkI7Ozs7Ozs7O09BUUc7SUFDSCxZQUNrQixHQUEyQixFQUMxQixLQUFlLEVBQ2YsR0FBcUI7UUFGdEIsUUFBRyxHQUFILEdBQUcsQ0FBd0I7UUFDMUIsVUFBSyxHQUFMLEtBQUssQ0FBVTtRQUNmLFFBQUcsR0FBSCxHQUFHLENBQWtCO0lBQUksQ0FBQztJQUU3Qzs7OztPQUlHO0lBQ0gsWUFBWSxDQUFDLE1B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QyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsR0FBRyxDQUFTLElBQWE7UUFDdkIsc0RBQXNEO1FBQ3RELE9BQU8sSUFBSSx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQVEsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDM0UsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VlcFVuc3RhYmxlVW50aWxGaXJzdCB9IGZyb20gJ0Bhbmd1bGFyL2ZpcmUnO1xuaW1wb3J0IGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlL2NvbXBhdC9hcHAnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZnJvbSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHBhaXJ3aXNlLCBzY2FuLCBzdGFydFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQgfSBmcm9tICcuLi9kb2N1bWVudC9kb2N1bWVudCc7XG5pbXBvcnQgeyBBbmd1bGFyRmlyZXN0b3JlIH0gZnJvbSAnLi4vZmlyZXN0b3JlJztcbmltcG9ydCB7IENvbGxlY3Rpb25SZWZlcmVuY2UsIERvY3VtZW50Q2hhbmdlQWN0aW9uLCBEb2N1bWVudENoYW5nZVR5cGUsIERvY3VtZW50RGF0YSwgRG9jdW1lbnRSZWZlcmVuY2UsIFF1ZXJ5IH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBmcm9tQ29sbGVjdGlvblJlZiB9IGZyb20gJy4uL29ic2VydmFibGUvZnJvbVJlZic7XG5pbXBvcnQgeyBkb2NDaGFuZ2VzLCBzb3J0ZWRDaGFuZ2VzIH0gZnJvbSAnLi9jaGFuZ2VzJztcblxudHlwZSBEb2N1bWVudENoYW5nZVR1cGxlPFQ+ID0gW0RvY3VtZW50Q2hhbmdlQWN0aW9uPFQ+W10sIERvY3VtZW50Q2hhbmdlQWN0aW9uPFQ+W11dO1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVFdmVudHNBcnJheShldmVudHM/OiBEb2N1bWVudENoYW5nZVR5cGVbXSkge1xuICBpZiAoIWV2ZW50cyB8fCBldmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZXZlbnRzID0gWydhZGRlZCcsICdyZW1vdmVkJywgJ21vZGlmaWVkJ107XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuLyoqXG4gKiBBbmd1bGFyRmlyZXN0b3JlQ29sbGVjdGlvbiBzZXJ2aWNlXG4gKlxuICogVGhpcyBjbGFzcyBjcmVhdGVzIGEgcmVmZXJlbmNlIHRvIGEgRmlyZXN0b3JlIENvbGxlY3Rpb24uIEEgcmVmZXJlbmNlIGFuZCBhIHF1ZXJ5IGFyZSBwcm92aWRlZCBpblxuICogaW4gdGhlIGNvbnN0cnVjdG9yLiBUaGUgcXVlcnkgY2FuIGJlIHRoZSB1bnF1ZXJpZWQgcmVmZXJlbmNlIGlmIG5vIHF1ZXJ5IGlzIGRlc2lyZWQuVGhlIGNsYXNzXG4gKiBpcyBnZW5lcmljIHdoaWNoIGdpdmVzIHlvdSB0eXBlIHNhZmV0eSBmb3IgZGF0YSB1cGRhdGUgbWV0aG9kcyBhbmQgZGF0YSBzdHJlYW1pbmcuXG4gKlxuICogVGhpcyBjbGFzcyB1c2VzIFN5bWJvbC5vYnNlcnZhYmxlIHRvIHRyYW5zZm9ybSBpbnRvIE9ic2VydmFibGUgdXNpbmcgT2JzZXJ2YWJsZS5mcm9tKCkuXG4gKlxuICogVGhpcyBjbGFzcyBpcyByYXJlbHkgdXNlZCBkaXJlY3RseSBhbmQgc2hvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgQW5ndWxhckZpcmVzdG9yZSBzZXJ2aWNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogY29uc3QgY29sbGVjdGlvblJlZiA9IGZpcmViYXNlLmZpcmVzdG9yZS5jb2xsZWN0aW9uKCdzdG9ja3MnKTtcbiAqIGNvbnN0IHF1ZXJ5ID0gY29sbGVjdGlvblJlZi53aGVyZSgncHJpY2UnLCAnPicsICcwLjAxJyk7XG4gKiBjb25zdCBmYWtlU3RvY2sgPSBuZXcgQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb248U3RvY2s+KGNvbGxlY3Rpb25SZWYsIHF1ZXJ5KTtcbiAqXG4gKiAvLyBOT1RFITogdGhlIHVwZGF0ZXMgYXJlIHBlcmZvcm1lZCBvbiB0aGUgcmVmZXJlbmNlIG5vdCB0aGUgcXVlcnlcbiAqIGF3YWl0IGZha2VTdG9jay5hZGQoeyBuYW1lOiAnRkFLRScsIHByaWNlOiAwLjAxIH0pO1xuICpcbiAqIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIGFzIHNuYXBzaG90cy4gVGhpcyBwcm92aWRlcyB5b3UgZGF0YSB1cGRhdGVzIGFzIHdlbGwgYXMgZGVsdGEgdXBkYXRlcy5cbiAqIGZha2VTdG9jay52YWx1ZUNoYW5nZXMoKS5zdWJzY3JpYmUodmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uPFQgPSBEb2N1bWVudERhdGE+IHtcbiAgLyoqXG4gICAqIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBpbiBhIENvbGxlY3Rpb25SZWZlcmVuY2UgYW5kIFF1ZXJ5IHRvIHByb3ZpZGUgd3JhcHBlciBtZXRob2RzXG4gICAqIGZvciBkYXRhIG9wZXJhdGlvbnMgYW5kIGRhdGEgc3RyZWFtaW5nLlxuICAgKlxuICAgKiBOb3RlOiBEYXRhIG9wZXJhdGlvbiBtZXRob2RzIGFyZSBkb25lIG9uIHRoZSByZWZlcmVuY2Ugbm90IHRoZSBxdWVyeS4gVGhpcyBtZWFuc1xuICAgKiB3aGVuIHlvdSB1cGRhdGUgZGF0YSBpdCBpcyBub3QgdXBkYXRpbmcgZGF0YSB0byB0aGUgd2luZG93IG9mIHlvdXIgcXVlcnkgdW5sZXNzXG4gICAqIHRoZSBkYXRhIGZpdHMgdGhlIGNyaXRlcmlhIG9mIHRoZSBxdWVyeS4gU2VlIHRoZSBBc3NvY2lhdGVkUmVmZW5jZSB0eXBlIGZvciBkZXRhaWxzXG4gICAqIG9uIHRoaXMgaW1wbGljYXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgcmVmOiBDb2xsZWN0aW9uUmVmZXJlbmNlPFQ+LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcXVlcnk6IFF1ZXJ5PFQ+LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYWZzOiBBbmd1bGFyRmlyZXN0b3JlKSB7IH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIHRoZSBsYXRlc3QgY2hhbmdlIGluIHRoZSBzdHJlYW0uIFRoaXMgbWV0aG9kIHJldHVybnMgY2hhbmdlc1xuICAgKiBhcyB0aGV5IG9jY3VyIGFuZCB0aGV5IGFyZSBub3Qgc29ydGVkIGJ5IHF1ZXJ5IG9yZGVyLiBUaGlzIGFsbG93cyB5b3UgdG8gY29uc3RydWN0XG4gICAqIHlvdXIgb3duIGRhdGEgc3RydWN0dXJlLlxuICAgKi9cbiAgc3RhdGVDaGFuZ2VzKGV2ZW50cz86IERvY3VtZW50Q2hhbmdlVHlwZVtdKTogT2JzZXJ2YWJsZTxEb2N1bWVudENoYW5nZUFjdGlvbjxUPltdPiB7XG4gICAgbGV0IHNvdXJjZSA9IGRvY0NoYW5nZXM8VD4odGhpcy5xdWVyeSwgdGhpcy5hZnMuc2NoZWR1bGVycy5vdXRzaWRlQW5ndWxhcik7XG4gICAgaWYgKGV2ZW50cyAmJiBldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgc291cmNlID0gc291cmNlLnBpcGUoXG4gICAgICAgIG1hcChhY3Rpb25zID0+IGFjdGlvbnMuZmlsdGVyKGNoYW5nZSA9PiBldmVudHMuaW5kZXhPZihjaGFuZ2UudHlwZSkgPiAtMSkpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICAvLyBXZSB3YW50IHRvIGZpbHRlciBvdXQgZW1wdHkgYXJyYXlzLCBidXQgYWx3YXlzIGVtaXQgYXQgZmlyc3QsIHNvIHRoZSBkZXZlbG9wZXIga25vd3NcbiAgICAgIC8vIHRoYXQgdGhlIGNvbGxlY3Rpb24gaGFzIGJlZW4gcmVzb2x2ZTsgZXZlbiBpZiBpdCdzIGVtcHR5XG4gICAgICBzdGFydFdpdGg8RG9jdW1lbnRDaGFuZ2VBY3Rpb248VD5bXSwgdW5kZWZpbmVkPih1bmRlZmluZWQpLFxuICAgICAgcGFpcndpc2UoKSxcbiAgICAgIGZpbHRlcigoW3ByaW9yLCBjdXJyZW50XTogRG9jdW1lbnRDaGFuZ2VUdXBsZTxUPikgPT4gY3VycmVudC5sZW5ndGggPiAwIHx8ICFwcmlvciksXG4gICAgICBtYXAoKFssIGN1cnJlbnRdKSA9PiBjdXJyZW50KSxcbiAgICAgIGtlZXBVbnN0YWJsZVVudGlsRmlyc3RcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN0cmVhbSBvZiBjaGFuZ2VzIGFzIHRoZXkgb2NjdXIgaXQgdGltZS4gVGhpcyBtZXRob2QgaXMgc2ltaWxhciB0byBzdGF0ZUNoYW5nZXMoKVxuICAgKiBidXQgaXQgY29sbGVjdHMgZWFjaCBldmVudCBpbiBhbiBhcnJheSBvdmVyIHRpbWUuXG4gICAqL1xuICBhdWRpdFRyYWlsKGV2ZW50cz86IERvY3VtZW50Q2hhbmdlVHlwZVtdKTogT2JzZXJ2YWJsZTxEb2N1bWVudENoYW5nZUFjdGlvbjxUPltdPiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVDaGFuZ2VzKGV2ZW50cykucGlwZShzY2FuKChjdXJyZW50LCBhY3Rpb24pID0+IFsuLi5jdXJyZW50LCAuLi5hY3Rpb25dLCBbXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN0cmVhbSBvZiBzeW5jaHJvbml6ZWQgY2hhbmdlcy4gVGhpcyBtZXRob2Qga2VlcHMgdGhlIGxvY2FsIGFycmF5IGluIHNvcnRlZFxuICAgKiBxdWVyeSBvcmRlci5cbiAgICovXG4gIHNuYXBzaG90Q2hhbmdlcyhldmVudHM/OiBEb2N1bWVudENoYW5nZVR5cGVbXSk6IE9ic2VydmFibGU8RG9jdW1lbnRDaGFuZ2VBY3Rpb248VD5bXT4ge1xuICAgIGNvbnN0IHZhbGlkYXRlZEV2ZW50cyA9IHZhbGlkYXRlRXZlbnRzQXJyYXkoZXZlbnRzKTtcbiAgICBjb25zdCBzY2hlZHVsZWRTb3J0ZWRDaGFuZ2VzJCA9IHNvcnRlZENoYW5nZXM8VD4odGhpcy5xdWVyeSwgdmFsaWRhdGVkRXZlbnRzLCB0aGlzLmFmcy5zY2hlZHVsZXJzLm91dHNpZGVBbmd1bGFyKTtcbiAgICByZXR1cm4gc2NoZWR1bGVkU29ydGVkQ2hhbmdlcyQucGlwZShcbiAgICAgIGtlZXBVbnN0YWJsZVVudGlsRmlyc3RcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBhbGwgZG9jdW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uIGFuZCBpdHMgcG9zc2libGUgcXVlcnkgYXMgYW4gT2JzZXJ2YWJsZS5cbiAgICpcbiAgICogSWYgdGhlIGBpZEZpZWxkYCBvcHRpb24gaXMgcHJvdmlkZWQsIGRvY3VtZW50IElEcyBhcmUgaW5jbHVkZWQgYW5kIG1hcHBlZCB0byB0aGVcbiAgICogcHJvdmlkZWQgYGlkRmllbGRgIHByb3BlcnR5IG5hbWUuXG4gICAqL1xuICB2YWx1ZUNoYW5nZXMoKTogT2JzZXJ2YWJsZTxUW10+O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHktcGF0dGVyblxuICB2YWx1ZUNoYW5nZXMoe30pOiBPYnNlcnZhYmxlPFRbXT47XG4gIHZhbHVlQ2hhbmdlczxLIGV4dGVuZHMgc3RyaW5nPihvcHRpb25zOiB7aWRGaWVsZDogS30pOiBPYnNlcnZhYmxlPChUICYgeyBbVCBpbiBLXTogc3RyaW5nIH0pW10+O1xuICB2YWx1ZUNoYW5nZXM8SyBleHRlbmRzIHN0cmluZz4ob3B0aW9uczoge2lkRmllbGQ/OiBLfSA9IHt9KTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICByZXR1cm4gZnJvbUNvbGxlY3Rpb25SZWY8VD4odGhpcy5xdWVyeSwgdGhpcy5hZnMuc2NoZWR1bGVycy5vdXRzaWRlQW5ndWxhcilcbiAgICAgIC5waXBlKFxuICAgICAgICBtYXAoYWN0aW9ucyA9PiBhY3Rpb25zLnBheWxvYWQuZG9jcy5tYXAoYSA9PiB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaWRGaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uYS5kYXRhKCkgYXMgYW55LFxuICAgICAgICAgICAgICAuLi57IFtvcHRpb25zLmlkRmllbGRdOiBhLmlkIH1cbiAgICAgICAgICAgIH0gYXMgVCAmIHsgW1QgaW4gS106IHN0cmluZyB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYS5kYXRhKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSksXG4gICAgICAgIGtlZXBVbnN0YWJsZVVudGlsRmlyc3RcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5IG9uY2UuXG4gICAqL1xuICBnZXQob3B0aW9ucz86IGZpcmViYXNlLmZpcmVzdG9yZS5HZXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIGZyb20odGhpcy5xdWVyeS5nZXQob3B0aW9ucykpLnBpcGUoXG4gICAgICBrZWVwVW5zdGFibGVVbnRpbEZpcnN0LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGRhdGEgdG8gYSBjb2xsZWN0aW9uIHJlZmVyZW5jZS5cbiAgICpcbiAgICogTm90ZTogRGF0YSBvcGVyYXRpb24gbWV0aG9kcyBhcmUgZG9uZSBvbiB0aGUgcmVmZXJlbmNlIG5vdCB0aGUgcXVlcnkuIFRoaXMgbWVhbnNcbiAgICogd2hlbiB5b3UgdXBkYXRlIGRhdGEgaXQgaXMgbm90IHVwZGF0aW5nIGRhdGEgdG8gdGhlIHdpbmRvdyBvZiB5b3VyIHF1ZXJ5IHVubGVzc1xuICAgKiB0aGUgZGF0YSBmaXRzIHRoZSBjcml0ZXJpYSBvZiB0aGUgcXVlcnkuXG4gICAqL1xuICBhZGQoZGF0YTogVCk6IFByb21pc2U8RG9jdW1lbnRSZWZlcmVuY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5yZWYuYWRkKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlZmVyZW5jZSB0byBhIHNpbmdsZSBkb2N1bWVudCBpbiBhIGNvbGxlY3Rpb24uXG4gICAqL1xuICBkb2M8VDIgPSBUPihwYXRoPzogc3RyaW5nKTogQW5ndWxhckZpcmVzdG9yZURvY3VtZW50PFQyPiB7XG4gICAgLy8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gc29sdmUgdGhpcyB0eXBlIGlzc3VlXG4gICAgcmV0dXJuIG5ldyBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQodGhpcy5yZWYuZG9jKHBhdGgpIGFzIGFueSwgdGhpcy5hZnMpO1xuICB9XG59XG4iXX0=